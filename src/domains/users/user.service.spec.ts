import { ConflictException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '@/providers/prisma/prisma.service';
import { CreateUserDto } from '@/users/dto/create-user.dto';
import { UpdateUserDto } from '@/users/dto/update-user.dto';
import { hash as hashUtil } from '@/utils/hash.util';

import { UserService } from './user.service';

jest.mock('@/utils/hash.util', () => ({
	hash: jest.fn((pw) => `hashed-${pw}`),
}));
jest.mock('@/utils/password-generator.util', () => ({
	generateStrongPassword: jest.fn(() => 'AutoPass123!'),
}));

const mockPrisma = {
	user: {
		create: jest.fn(),
		findMany: jest.fn(),
		findFirst: jest.fn(),
		findUnique: jest.fn(),
		update: jest.fn(),
		delete: jest.fn(),
	},
};

describe('UserService', () => {
	let service: UserService;
	const userId = 'user-1';

	beforeEach(async () => {
		const module: TestingModule = await Test.createTestingModule({
			providers: [
				UserService,
				{ provide: PrismaService, useValue: mockPrisma },
			],
		}).compile();

		service = module.get<UserService>(UserService);
		jest.clearAllMocks();
	});

	describe('create', () => {
		it('should create and return a new user with provided password', async () => {
			const dto: CreateUserDto = {
				email: 'a@a.com',
				fullName: 'User A',
				password: 'Password123!',
				gender: 'Male',
				phoneNumber: '0123456789',
				isActive: true,
			};
			mockPrisma.user.findFirst.mockResolvedValue(null);
			const created = { id: userId, ...dto, password: 'hashed-Password123!' };
			mockPrisma.user.create.mockResolvedValue(created);

			const result = await service.create(dto);
			expect(result).toEqual({
				id: created.id,
				email: created.email,
				fullName: created.fullName,
				gender: created.gender,
				phoneNumber: created.phoneNumber,
				isActive: created.isActive,
				autoGeneratedPassword: undefined,
			});
			expect(mockPrisma.user.findFirst).toHaveBeenCalled();
			expect(hashUtil).toHaveBeenCalledWith(dto.password);
			expect(mockPrisma.user.create).toHaveBeenCalledWith({
				data: {
					...dto,
					password: 'hashed-Password123!',
				},
			});
		});

		it('should create and return a new user with auto-generated password', async () => {
			const dto: CreateUserDto = {
				email: 'a@a.com',
				fullName: 'User A',
				gender: 'Male',
				phoneNumber: '0123456789',
				isActive: true,
				password: '',
			};
			mockPrisma.user.findFirst.mockResolvedValue(null);
			const created = { id: userId, ...dto, password: 'hashed-AutoPass123!' };
			mockPrisma.user.create.mockResolvedValue(created);

			const result = await service.create(dto);
			expect(result).toEqual({
				id: created.id,
				email: created.email,
				fullName: created.fullName,
				gender: created.gender,
				phoneNumber: created.phoneNumber,
				isActive: created.isActive,
				autoGeneratedPassword: 'AutoPass123!',
			});
			expect(hashUtil).toHaveBeenCalledWith('AutoPass123!');
		});

		it('should throw if user already exists', async () => {
			const dto: CreateUserDto = {
				email: 'a@a.com',
				phoneNumber: '0123456789',
			} as CreateUserDto;
			mockPrisma.user.findFirst.mockResolvedValue({ id: userId });

			await expect(service.create(dto)).rejects.toThrow(ConflictException);
			expect(mockPrisma.user.create).not.toHaveBeenCalled();
		});

		it('should throw on error', async () => {
			const dto: CreateUserDto = {
				email: 'a@a.com',
				phoneNumber: '0123456789',
			} as CreateUserDto;
			mockPrisma.user.findFirst.mockRejectedValue(new Error('fail'));
			await expect(service.create(dto)).rejects.toThrow('fail');
		});
	});

	describe('findAll', () => {
		it('should return all users', async () => {
			const users = [{ id: userId }, { id: 'user-2' }];
			mockPrisma.user.findMany.mockResolvedValue(users);

			const result = await service.findAll();
			expect(result).toEqual(users);
			expect(mockPrisma.user.findMany).toHaveBeenCalled();
		});

		it('should throw on error', async () => {
			mockPrisma.user.findMany.mockRejectedValue(new Error('fail'));
			await expect(service.findAll()).rejects.toThrow('fail');
		});
	});

	describe('findOne', () => {
		it('should return a user by id', async () => {
			const user = {
				id: userId,
				email: 'a@a.com',
				fullName: 'User A',
				password: 'hashed-Password123!',
				gender: 'Male',
				phoneNumber: '0123456789',
				isActive: true,
			};
			mockPrisma.user.findUnique.mockResolvedValue(user);

			const result = await service.findOne(userId);
			expect(result).toEqual(user);
			expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
				where: { id: userId },
			});
		});

		it('should return null if not found', async () => {
			mockPrisma.user.findUnique.mockResolvedValue(null);
			const result = await service.findOne('notfound');
			expect(result).toBeNull();
		});

		it('should throw on error', async () => {
			mockPrisma.user.findUnique.mockRejectedValue(new Error('fail'));
			await expect(service.findOne(userId)).rejects.toThrow('fail');
		});
	});

	describe('update', () => {
		it('should update and return the user with hashed password', async () => {
			const dto: UpdateUserDto = { fullName: 'User B', password: 'pw' };
			const updated = { id: userId, fullName: 'User B', password: 'hashed-pw' };
			mockPrisma.user.findUnique.mockResolvedValue({ id: userId });
			mockPrisma.user.update.mockResolvedValue(updated);

			const result = await service.update(userId, dto);
			expect(result).toEqual(updated);
			expect(hashUtil).toHaveBeenCalledWith('pw');
			expect(mockPrisma.user.update).toHaveBeenCalledWith({
				where: { id: userId },
				data: { fullName: 'User B', password: 'hashed-pw' },
			});
		});

		it('should update and return the user without password', async () => {
			const dto: UpdateUserDto = { fullName: 'User B' };
			const updated = { id: userId, fullName: 'User B' };
			mockPrisma.user.findUnique.mockResolvedValue({ id: userId });
			mockPrisma.user.update.mockResolvedValue(updated);

			const result = await service.update(userId, dto);
			expect(result).toEqual(updated);
			expect(mockPrisma.user.update).toHaveBeenCalledWith({
				where: { id: userId },
				data: { fullName: 'User B' },
			});
		});

		it('should throw ConflictException if user not found', async () => {
			mockPrisma.user.findUnique.mockResolvedValue(null);
			await expect(service.update(userId, {} as UpdateUserDto)).rejects.toThrow(
				ConflictException,
			);
		});

		it('should throw on error', async () => {
			mockPrisma.user.findUnique.mockResolvedValue({ id: userId });
			mockPrisma.user.update.mockRejectedValue(new Error('fail'));
			await expect(service.update(userId, {} as UpdateUserDto)).rejects.toThrow(
				'fail',
			);
		});
	});

	describe('remove', () => {
		it('should delete the user and return status/message', async () => {
			const deleted = { id: userId };
			mockPrisma.user.delete.mockResolvedValue(deleted);

			const result = await service.remove(userId);
			expect(result).toEqual({
				status: 'success',
				message: `User with ID ${userId} deleted successfully`,
			});
			expect(mockPrisma.user.delete).toHaveBeenCalledWith({
				where: { id: userId },
			});
		});

		it('should throw ConflictException if not found', async () => {
			const error: any = new Error('not found');
			error.code = 'P2025';
			mockPrisma.user.delete.mockRejectedValue(error);

			await expect(service.remove(userId)).rejects.toThrow(ConflictException);
		});

		it('should throw on error', async () => {
			mockPrisma.user.delete.mockRejectedValue(new Error('fail'));
			await expect(service.remove(userId)).rejects.toThrow('fail');
		});
	});
});
