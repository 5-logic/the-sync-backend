import { ConflictException, Injectable, Logger } from '@nestjs/common';

import { PrismaService } from '@/providers/prisma/prisma.service';
import { CreateUserDto } from '@/users/dto/create-user.dto';
import { UpdateUserDto } from '@/users/dto/update-user.dto';
import { hash } from '@/utils/hash.util';
import { generateStrongPassword } from '@/utils/password-generator.util';

@Injectable()
export class UserService {
	private readonly logger = new Logger(UserService.name);

	constructor(private readonly prisma: PrismaService) {}

	async create(createUserDto: CreateUserDto) {
		try {
			const existingUser = await this.prisma.user.findFirst({
				where: {
					OR: [
						{ email: createUserDto.email },
						{ phoneNumber: createUserDto.phoneNumber },
					],
				},
			});
			if (existingUser) {
				this.logger.warn(
					`User with email ${createUserDto.email} or phone ${createUserDto.phoneNumber} already exists`,
				);
				throw new ConflictException(
					'User with this email or phone already exists',
				);
			}

			let password = createUserDto.password;
			let autoGeneratedPassword: string | undefined = undefined;
			if (!password) {
				password = generateStrongPassword();
				autoGeneratedPassword = password;
			}

			const hashedPassword = await hash(password);

			const newUser = await this.prisma.user.create({
				data: {
					...createUserDto,
					password: hashedPassword,
				},
			});

			this.logger.log(`User created with ID: ${newUser.id}`);
			this.logger.debug('User detail', newUser);

			return {
				id: newUser.id,
				email: newUser.email,
				fullName: newUser.fullName,
				gender: newUser.gender,
				phoneNumber: newUser.phoneNumber,
				isActive: newUser.isActive,
				autoGeneratedPassword,
			};
		} catch (error) {
			this.logger.error('Error creating user', error);
			throw error;
		}
	}

	async findAll() {
		try {
			this.logger.log('Fetching all users');
			return await this.prisma.user.findMany();
		} catch (error) {
			this.logger.error('Error fetching users', error);
			throw error;
		}
	}

	async findOne(id: string) {
		try {
			this.logger.log(`Fetching user with id: ${id}`);
			const user = await this.prisma.user.findUnique({
				where: { id },
			});
			if (!user) {
				this.logger.warn(`User with ID ${id} not found`);
				return null;
			}
			return user;
		} catch (error) {
			this.logger.error('Error fetching user', error);
			throw error;
		}
	}

	async update(id: string, updateUserDto: UpdateUserDto) {
		try {
			const existingUser = await this.prisma.user.findUnique({
				where: { id },
			});
			if (!existingUser) {
				this.logger.warn(`User with ID ${id} not found for update`);
				throw new ConflictException(`User with ID ${id} not found`);
			}

			// Nếu có password mới, hash lại
			const dataToUpdate: any = { ...updateUserDto };
			if (updateUserDto.password) {
				dataToUpdate.password = await hash(updateUserDto.password);
			}

			const updatedUser = await this.prisma.user.update({
				where: { id },
				data: dataToUpdate,
			});

			this.logger.log(`User updated with ID: ${updatedUser.id}`);
			this.logger.debug('Updated User', updatedUser);

			return updatedUser;
		} catch (error) {
			this.logger.error('Error updating user', error);
			throw error;
		}
	}

	async remove(id: string) {
		try {
			this.logger.log(`Removing user with id: ${id}`);
			const deletedUser = await this.prisma.user.delete({
				where: { id },
			});

			this.logger.log(`User deleted with ID: ${deletedUser.id}`);

			return {
				status: 'success',
				message: `User with ID ${deletedUser.id} deleted successfully`,
			};
		} catch (error) {
			if (error.code === 'P2025') {
				this.logger.warn(`User with ID ${id} not found for deletion`);
				throw new ConflictException(`User with ID ${id} not found`);
			}
			this.logger.error('Error deleting user', error);
			throw error;
		}
	}
}
