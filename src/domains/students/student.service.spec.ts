import { ConflictException, NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '@/providers/prisma.service';
import { StudentService } from '@/students/student.service';
import { UserService } from '@/users/user.service';

jest.mock('@/utils/hash.util', () => ({
	hash: jest.fn((pw) => `hashed-${pw}`),
}));

const mockPrisma = {
	student: {
		create: jest.fn(),
		findMany: jest.fn(),
		findUnique: jest.fn(),
		update: jest.fn(),
		delete: jest.fn(),
	},
	user: {
		create: jest.fn(),
		update: jest.fn(),
		delete: jest.fn(),
	},
	$transaction: jest.fn((cb) => cb(mockPrisma)),
};

const mockUserService = {
	create: jest.fn(),
};

describe('StudentService', () => {
	let service: StudentService;
	const userId = 'user-1';

	beforeEach(async () => {
		const module: TestingModule = await Test.createTestingModule({
			providers: [
				StudentService,
				{ provide: PrismaService, useValue: mockPrisma },
				{ provide: UserService, useValue: mockUserService },
			],
		}).compile();

		service = module.get<StudentService>(StudentService);
		jest.clearAllMocks();
	});

	describe('create', () => {
		it('should create and return a new student', async () => {
			const dto = {
				createUserDto: { email: 'a' },
				studentId: 'st1',
				roles: [],
				skills: [],
				academicInterests: [],
				majorId: 'major-1',
			};
			const newUser = { id: userId, autoGeneratedPassword: 'pass' };
			mockUserService.create.mockResolvedValue(newUser);
			mockPrisma.student.findUnique.mockResolvedValue(null);
			const created = {
				userId,
				studentId: 'st1',
				roles: [],
				skills: [],
				academicInterests: [],
				majorId: 'major-1',
				groups: [{ id: 'group1' }, { id: 'group2' }],
			};
			mockPrisma.student.create.mockResolvedValue(created);

			const result = await service.create(dto as any);
			expect(result).toEqual({
				...created,
				groups: ['group1', 'group2'],
			});
		});

		it('should throw ConflictException if student exists', async () => {
			const dto = {
				createUserDto: { email: 'a' },
				studentId: 'st1',
				roles: [],
				skills: [],
				academicInterests: [],
				majorId: 'major-1',
			};
			const newUser = { id: userId };
			mockUserService.create.mockResolvedValue(newUser);
			mockPrisma.student.findUnique.mockResolvedValue({ userId });

			await expect(service.create(dto as any)).rejects.toThrow(
				ConflictException,
			);
		});
	});

	describe('findAll', () => {
		it('should return all students', async () => {
			const students = [
				{ userId, groups: [{ id: 'group1' }] },
				{ userId: 'user-2', groups: [{ id: 'group2' }] },
			];
			mockPrisma.student.findMany.mockResolvedValue(students);

			const result = await service.findAll();
			expect(result).toEqual(students);
			expect(mockPrisma.student.findMany).toHaveBeenCalledWith({
				include: { groups: { select: { id: true } } },
			});
		});

		it('should throw on error', async () => {
			mockPrisma.student.findMany.mockRejectedValue(new Error('fail'));
			await expect(service.findAll()).rejects.toThrow('fail');
		});
	});

	describe('findOne', () => {
		it('should return a student by userId', async () => {
			const student = { userId, groups: [{ id: 'group1' }, { id: 'group2' }] };
			mockPrisma.student.findUnique.mockResolvedValue(student);

			const result = await service.findOne(userId);
			expect(result).toEqual(student);
			expect(mockPrisma.student.findUnique).toHaveBeenCalledWith({
				where: { userId },
				include: { groups: { select: { id: true } } },
			});
		});

		it('should throw NotFoundException if not found', async () => {
			mockPrisma.student.findUnique.mockResolvedValue(null);
			await expect(service.findOne('notfound')).rejects.toThrow(
				NotFoundException,
			);
		});

		it('should throw on error', async () => {
			mockPrisma.student.findUnique.mockRejectedValue(new Error('fail'));
			await expect(service.findOne(userId)).rejects.toThrow('fail');
		});
	});

	describe('update', () => {
		it('should update user and student and return the student', async () => {
			const dto = {
				createUserDto: { email: 'a', password: 'pw' },
				studentId: 'st1',
				roles: [],
				skills: [],
				academicInterests: [],
				majorId: 'major-1',
			};
			const updated = { userId, groups: [{ id: 'group1' }] };
			mockPrisma.user.update.mockResolvedValue({});
			mockPrisma.student.update.mockResolvedValue(updated);

			const result = await service.update(userId, dto as any);
			expect(mockPrisma.user.update).toHaveBeenCalledWith({
				where: { id: userId },
				data: { email: 'a', password: 'hashed-pw' },
			});
			expect(result).toEqual(updated);
		});

		it('should update only student if no createUserDto', async () => {
			const dto = {
				studentId: 'st1',
				roles: [],
				skills: [],
				academicInterests: [],
				majorId: 'major-1',
			};
			const updated = { userId, groups: [{ id: 'group1' }] };
			mockPrisma.student.update.mockResolvedValue(updated);

			const result = await service.update(userId, dto as any);
			expect(result).toEqual(updated);
		});

		it('should throw on error', async () => {
			mockPrisma.student.update.mockRejectedValue(new Error('fail'));
			await expect(service.update(userId, {} as any)).rejects.toThrow('fail');
		});
	});

	describe('remove', () => {
		it('should delete the student and user and return status/message', async () => {
			const deleted = { userId };
			mockPrisma.student.delete.mockResolvedValue(deleted);
			mockPrisma.user.delete.mockResolvedValue({});

			const result = await service.remove(userId);
			expect(result).toEqual({
				status: 'success',
				message: `Student and user with userId ${userId} deleted successfully`,
			});
			expect(mockPrisma.student.delete).toHaveBeenCalledWith({
				where: { userId },
			});
			expect(mockPrisma.user.delete).toHaveBeenCalledWith({
				where: { id: userId },
			});
		});

		it('should throw NotFoundException if not found', async () => {
			const error: any = new Error('not found');
			error.code = 'P2025';
			mockPrisma.student.delete.mockRejectedValue(error);

			await expect(service.remove(userId)).rejects.toThrow(NotFoundException);
		});

		it('should throw on error', async () => {
			mockPrisma.student.delete.mockRejectedValue(new Error('fail'));
			await expect(service.remove(userId)).rejects.toThrow('fail');
		});
	});
});
