import {
	ConflictException,
	Injectable,
	Logger,
	NotFoundException,
} from '@nestjs/common';

import { CreateLecturerDto } from '@/lecturers/dto/create-lecturer.dto';
import { UpdateLecturerDto } from '@/lecturers/dto/update-lecturer.dto';
import { PrismaService } from '@/providers/prisma.service';
import { UserService } from '@/users/user.service';
import { hash } from '@/utils/hash.util';

@Injectable()
export class LecturerService {
	private readonly logger = new Logger(LecturerService.name);

	constructor(
		private readonly prisma: PrismaService,
		private readonly userService: UserService,
	) {}

	async create(createLecturerDto: CreateLecturerDto): Promise<any> {
		try {
			const result = await this.prisma.$transaction(async (prisma) => {
				const newUser = await this.userService.create(
					createLecturerDto.createUserDto,
				);
				const userId = newUser.id;

				const existingLecturer = await prisma.lecturer.findUnique({
					where: { userId },
				});
				if (existingLecturer) {
					this.logger.warn(`Lecturer with userId ${userId} already exists`);
					throw new ConflictException(
						`Lecturer with userId ${userId} already exists`,
					);
				}

				const newLecturer = await prisma.lecturer.create({
					data: { userId },
					include: {
						groups: { select: { id: true } },
						feedbacks: true,
					},
				});

				return {
					...newLecturer,
					groups: newLecturer.groups?.map((g) => g.id) ?? [],
					autoGeneratedPassword: newUser.autoGeneratedPassword,
				};
			});

			this.logger.log(`Lecturer created with userId: ${result.userId}`);
			this.logger.debug('New Lecturer', result);

			return result;
		} catch (error) {
			this.logger.error('Error creating lecturer', error);
			throw error;
		}
	}

	async findAll(): Promise<any[]> {
		try {
			const lecturers = await this.prisma.lecturer.findMany({
				include: {
					groups: { select: { id: true } },
					feedbacks: true,
				},
			});

			this.logger.log(`Found ${lecturers.length} lecturers`);

			return lecturers.map((l) => ({
				...l,
				groups: l.groups?.map((g) => g.id) ?? [],
			}));
		} catch (error) {
			this.logger.error('Error fetching lecturers', error);
			throw error;
		}
	}

	async findOne(userId: string): Promise<any> {
		try {
			const lecturer = await this.prisma.lecturer.findUnique({
				where: { userId },
				include: {
					groups: { select: { id: true } },
					feedbacks: true,
				},
			});

			if (!lecturer) {
				this.logger.warn(`Lecturer with userId ${userId} not found`);
				throw new NotFoundException(`Lecturer with userId ${userId} not found`);
			}

			this.logger.log(`Lecturer found with userId: ${userId}`);

			return {
				...lecturer,
				groups: lecturer.groups?.map((g) => g.id) ?? [],
			};
		} catch (error) {
			this.logger.error(`Error fetching lecturer with userId ${userId}`, error);
			throw error;
		}
	}

	async update(
		userId: string,
		updateLecturerDto: UpdateLecturerDto,
	): Promise<any> {
		try {
			const result = await this.prisma.$transaction(async (prisma) => {
				if (updateLecturerDto.createUserDto) {
					const { password, ...userFields } = updateLecturerDto.createUserDto;
					const dataToUpdate: any = { ...userFields };

					if (password) {
						dataToUpdate.password = await hash(password);
					}

					await prisma.user.update({
						where: { id: userId },
						data: dataToUpdate,
					});
				}

				const lecturerFields = { ...updateLecturerDto };
				delete lecturerFields.createUserDto;

				const updatedLecturer = await prisma.lecturer.update({
					where: { userId },
					data: lecturerFields,
					include: {
						groups: { select: { id: true } },
						feedbacks: true,
					},
				});

				return {
					...updatedLecturer,
					groups: updatedLecturer.groups?.map((g) => g.id) ?? [],
				};
			});

			this.logger.log(`Lecturer updated with userId: ${userId}`);
			this.logger.debug('Updated Lecturer', result);

			return result;
		} catch (error) {
			if (error.code === 'P2025') {
				this.logger.warn(`Lecturer with userId ${userId} not found for update`);
				throw new ConflictException(`Lecturer with userId ${userId} not found`);
			}
			this.logger.error(`Error updating lecturer with userId ${userId}`, error);
			throw error;
		}
	}

	async remove(userId: string): Promise<any> {
		try {
			const deletedLecturer = await this.prisma.lecturer.delete({
				where: { userId },
				include: { groups: { select: { id: true } } },
			});

			await this.prisma.user.delete({ where: { id: userId } });

			this.logger.log(
				`Lecturer and user deleted with userId: ${deletedLecturer.userId}`,
			);
			this.logger.debug('Deleted Lecturer', deletedLecturer);

			return {
				status: 'success',
				message: `Lecturer and user with userId ${deletedLecturer.userId} deleted successfully`,
				groups: deletedLecturer.groups?.map((g) => g.id) ?? [],
			};
		} catch (error) {
			if (error.code === 'P2025') {
				this.logger.warn(`Lecturer with userId ${userId} not found`);
				throw new NotFoundException(`Lecturer with userId ${userId} not found`);
			}
			this.logger.error(`Error deleting lecturer with userId ${userId}`, error);
			throw error;
		}
	}
}
